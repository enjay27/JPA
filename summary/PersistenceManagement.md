# 영속성 관리

> JPA는 크게 엔티티와 테이블을 매핑하는 설계부분,
>
> 매핑한 엔티티를 실제 사용하는 부분으로 나뉜다.
 
## Entity Manager Factory & Entity Manager

엔티티 매니저 팩토리를 사용하여 엔티티 매니저를 생성한다.

엔티티 매니저 팩토리는 생성 비용이 많이 든다.

엔티티 매니저는 스레드 안전하지 않으므로 공유해서는 안 된다.

엔티티 매니저는 데이터베이스 연결이 필요한 시점까지 커넥션을 얻지 않는다. 보통 트랜잭션을 시작할 때 커넥션을 얻는다.

## Persistence Context

> 엔티티를 영구 저장하는 환경

엔티티 매니저의 persist() 를 사용하면 엔티티를 영속성 컨텍스트에 저장한다.

## Entity Life Cycle

1. 비영속 (new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
2. 영속 (managed) : 영속성 컨텍스트에 저장된 상태
3. 준영속 (detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
4. 삭제 (removed) : 삭제된 상태

![Entity Life Cycle](https://www.objectdb.com/files/images/manual/jpa-states.png)

## Persistence Context

- 영속성 컨텍스트는 엔티티를 @id 로 구분한다. 반드시 있어야 한다.
- flush 가 발생하면 영속성 컨텍스트의 엔티티가 데이터베이스에 저장된다.
- 다음과 같은 장점이 있다
  - 1차캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

### 1차 캐시
> 영속성 컨텍스트 내부의 캐시. 영속 상태의 엔티티는 모두 여기에 저장된다.
>
> Map<@id, Entity>

em.find() 를 호출하면 1차캐시에서 엔티티를 찾고, 엔티티가 없다면 데이터베이스에서 조회한다.

![first level cache](https://vladmihalcea.com/wp-content/uploads/2020/10/EntityLoadingControlFlow.png)

1차 캐시에서 엔티티를 불러온 후 ==(identity) 비교를 하면 참이 된다.

영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.


### 엔티티 등록

엔티티 매니저는 데이터베이스에 엔티티를 저장하지 않고 쿼리 저장소에 SQL을 모은다.

이후 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는 것을 쓰기 지연이라고 한다.

![Transactional-write behind cache](https://vladmihalcea.com/wp-content/uploads/2015/04/cachewritebehind.png)


### 변경 감지

> 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능

엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 스냅샷 해 둔다.

이후 플러시 시점에 스냅샷과 엔티티를 비교하여 변경된 엔티티를 찾는다.

![dirty-checking](https://vladmihalcea.com/wp-content/uploads/2014/08/defaultflusheventflow1.png)

변경 감지는 영속 상태의 엔티티에만 적용된다.

그리고 JPA의 기본 변경 감지 전략은 변경된 엔티티의 모든 필드를 업데이트한다.
 - 수정된 쿼리가 항상 같아 애플리케이션 로딩 시점에 미리 생성해두고 재사용이 가능하다.
 - 동일한 쿼리를 보내면 이전에 파싱되었던 쿼리를 재사용할 수 있다.

### 삭제

remove() 에 대상 엔티티를 점겨주면 엔티티가 삭제된다. 

삭제도 쓰기 지연 SQL 저장소에 등록된 후 플러시를 호출하면 데이터베이스에 삭제 쿼리를 전달한다.

remove(Entity) 를 호출하는 순간 Entity 는 영속성 컨텍스트에서 제거된다.

### 플러시

> 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. (변경 내용을 데이터베이스에 동기화)
1. 변경 감지가 동작하여 수정된 엔티티를 찾고 실행할 쿼리를 지연 SQL 저장소에 등록한다.
2. 쿼리를 데이터베이스에 전송한다. (CRUD)

플러시 방법
 - flush() 메서드로 직접호출 : 테스트 또는 다른 프레임워크에서 사용할 때를 제외하곤 사용하지 않는다.
 - 트랜잭션 커밋 : 트랜잭션을 커밋할 때 자동으로 호출한다.
 - JPQL 쿼리 실행 : 객체지향 쿼리 호출 시 자동으로 호출된다.

#### __모드__
- FlushModeType.AUTO : 기본값. 커밋이나 쿼리 실행 시 플러시
- FlushModeType.COMMIT : 커밋할 때만 플러시

COMMIT 모드는 성능 최적화를 위해 사용할 수 있다. (10장)

### 준영속

> 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것
>
> 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.

특징 : 
 - 비영속에 가깝다. 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 어떠한 기능도 동작하지 않는다.
 - 식별자 값을 가지고 있다. 영속 상태에서 준영속 상태가 된 것이기 때문에 반드시 가지고 있다.
 - 지연 로딩이 불가능하다. 프록시 객체를 로딩해두고 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법을 사용할 수 없다.

메서드 :
 - em.detach(entity) : 특정 엔티티를 준영속 상태로 전환한다.
 - em.clear() : 영속성 컨텍스트를 초기화한다. 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만든다.
 - em.close() : 영속성 컨텍스트를 종료한다. 모든 엔티티를 준영속 상태로 만든다.
 - em.merge() : 준영속 상태의 엔티티를 받아서 그 정보로 새로운 영속 상태의 엔티티를 반환한다. 비영속 상태의 엔티티도 영속 상태로 만들 수 있다. (save or update)

![persistence](https://vladmihalcea.com/wp-content/uploads/2014/07/jpaentitystates.png)
